
```ts
function orangesRotting(grid: number[][]): number {
    let totalRotten=0;
    let minute=0;
    const dfs = (row,column,minute)=>{
        console.log(row,column)
        progression.push(minute);
        const r = grid.length;
        const c = grid[0].length;

        if(row+1 < r && grid[row+1][column] === 1){
            grid[row+1][column]=2;
            dfs(row+1,column,minute+1);
        }
        if(row-1 > 0 && grid[row-1][column] === 1){
            grid[row-1][column]=2;
            dfs(row+1,column,minute+1);
        }

        if(column+1 < c && grid[row][column+1] === 1){
            grid[row][column+1]=2;
            dfs(row,column+1,minute+1);
        }

        if(column-1 > 0 && grid[row][column-1] === 1){
            grid[row][column-1]=2;
            dfs(row,column-1,minute+1);
        }
    };

    let row = grid.length;
    let col = grid[0].length;
    for(let r=0;r<row;r++){
        for(let c=0;c<col;c++){
            if(grid[r][c] == 0){
                continue;
            }
            if(grid[r][c]==2){
                totalRotten+=1;
                dfs(r,c,progression);
            }
        }
    }
    console.log(progression);
    return totalRotten;
};

```

Idea: do dfs on each rotten one -> 
      for each rotten one -> do four directions and do dfs and make it rotten
     cant solve how to find minute rotten progression


# Mistake

üîç Visual Grid Example:
[
  [1, 1, 1],
  [1, 2, 1],
  [1, 1, 1]
]
If you're at (1, 1) and want to check all four directions, your logic should reach:

Up ‚Üí (0, 1)

Down ‚Üí (2, 1)

Left ‚Üí (1, 0) ‚úÖ (this is col - 1 = 0)

Right ‚Üí (1, 2)

But if your check is col - 1 > 0, it skips (1, 0) ‚ùå




üçä Rotting Oranges ‚Äì Learning Log and README
üéØ Goal:
Simulate the minute-by-minute rotting process of oranges in a grid, where each rotten orange spreads rot to its adjacent fresh oranges (up, down, left, right) per minute.

üß† My Initial Thought Process
I started with a DFS (Depth-First Search) approach.

For every rotten orange, I recursively visited its 4 neighbors.

If a neighbor was fresh (1), I turned it rotten (2) and called DFS again.

I tried to track the "minute" progression with a minute counter and progression.push(minute) to record the time.

‚ùå What Went Wrong
1. Wrong boundary check


if (column - 1 > 0)  // ‚ùå skips column 0 (valid index)
This caused valid cells like (1, 0) to be missed.

Fixed with: if (column - 1 >= 0)

2. DFS is not suitable for tracking 'minutes'
DFS explores deep into one path rather than level-by-level.

It doesn't naturally simulate the idea of each minute infecting all immediate neighbors.

3. I didn‚Äôt consider collective rot progression
I was calling DFS separately for each rotten orange.

I didn‚Äôt realize I need to treat all initial rotten oranges as starting points and spread simultaneously ‚Äî this is key to mimicking the real-world spread.

‚úÖ The Correct Approach: BFS
üß† Why BFS?
BFS (Breadth-First Search) simulates minute-by-minute progression.

It explores all current rotten oranges‚Äô neighbors first (minute 1),
then those newly rotten oranges' neighbors (minute 2), and so on.

This matches the idea of rot spreading outward in waves.

üìã Steps:
Count all fresh oranges.

Collect all initially rotten oranges and add them to a queue.

While the queue is not empty:

For each orange in the queue (current minute),

Check its 4 neighbors.

If a neighbor is fresh, rot it and add it to the queue.

Decrease the fresh count.

Increment the minute counter after processing the whole queue level.

If there are fresh oranges left at the end ‚Üí return -1.

üß™ Visual Understanding
Grid:

[ [1, 1, 1],
  [1, 2, 1],
  [1, 1, 1] ]
Minute 0: (1, 1) is rotten.

Minute 1: (0,1), (1,0), (1,2), (2,1) become rotten.

Minute 2: the rot spreads further.

üõ†Ô∏è Final Takeaways
‚úÖ Use >= 0 for boundary checks to include index 0.

‚ùå DFS is good for deep paths, but not for wave-like time-based spread.

‚úÖ Use BFS when:

You need to model layers or waves

You‚Äôre tracking steps or minimum time to reach a state

‚úÖ Always collect initial sources (in this case, all rotten oranges) before starting the traversal.

üîÅ Efficient Direction Iteration ‚Äì What I Learned
‚ùì Problem Before
At first, I wrote separate if statements for each possible direction:

```ts

if (row + 1 < rows && grid[row + 1][col] === 1) { ... }
if (row - 1 >= 0 && grid[row - 1][col] === 1) { ... }
if (col + 1 < cols && grid[row][col + 1] === 1) { ... }
if (col - 1 >= 0 && grid[row][col - 1] === 1) { ... }
```
This was:

Repetitive

Easy to make mistakes (like off-by-one errors)

Hard to maintain or scale if I wanted to explore diagonal directions

‚úÖ The Better Way: directions Array
I learned to use a direction vector array:

```ts
const directions = [
  [1, 0],   // down
  [-1, 0],  // up
  [0, 1],   // right
  [0, -1]   // left
];
```
Then loop through them:

```ts
for (const [dr, dc] of directions) {
    const newRow = row + dr;
    const newCol = col + dc;

    if (
        newRow >= 0 && newRow < rows &&
        newCol >= 0 && newCol < cols &&
        grid[newRow][newCol] === 1
    ) {
        grid[newRow][newCol] = 2;
        queue.push([newRow, newCol]);
    }
}
```
‚úÖ Benefits:
Cleaner code

Easier to debug and maintain

More scalable (can add diagonal directions by extending directions)

Reduces repeated logic ‚Äî DRY (Don't Repeat Yourself) principle

